"Календарь" планировщик задач.
Возможности
Регистрация/аутентификация через вк.
Создание целей.
Выбор временного интервала цели с отображением количества дней до завершения цели.
Выбор категории цели (личные, работа, развитие, спорт и т. п.) с возможностью добавлять/удалять/обновлять категории.
Выбор приоритета цели (статичный список minor, major, critical и т. п.).
Выбор статуса выполнения цели (в работе, выполнен, просрочен, в архиве).
Изменение целей.
Изменение описания цели.
Изменение статуса.
Возможность менять приоритет и категорию у цели.
Удаление цели (статус "в архиве").
Поиск по названию цели.
Фильтрация по статусу, категории, приоритету, году.
Выгрузка целей в CSV/JSON.
Добавление заметок к целям.
Stack
Python 3.10, Django 4.0.1, Postgres

Запуск приложения:
Установить зависимости
Заполнить .env со значениями, в котором следует хранить настройки по умолчанию;
Накатить миграции.
Запустить проект.


Последовательность создания Веб-приложения — планировщик задач:
Шаг 1-2.
Создали приложение todolist. Добавили файл requirements.txt, установили зависимости, указанные в нем.
Шаг 3.
Установили библиотеку python-dotenv. Создали файл .env, в котором хранятся настройки по умолчанию.
Создали приложение core.
В файле core/models.py добавили модель пользователя, которая наследуется от 
AbstractUser.
Установили Postgres, подключились, сделали миграции, сформировали таблицы.
Создали суперюзера. В админке:
- Отобразили поля в списке
- Добавили поиск по полям
- Добавили фильтры по полям
- Скрыть поле Password.
- Сделать поля неизменяемыми: Last login, Date joined.

Шаг 4.
Написали Dockerfile и docker-compose.yaml, запустили 4 контейнера.
Создали специального пользователя deploy c правами администратора.
  <adduser deploy>
Завели файл в проекте 
.github/actions/action.yaml
Внутри него описали джобу, которая:
Собирает образ с помощью docker build
Выполняет логин в Docker Hub с помощью docker login
Отправляет образ в Docker Hub с помощью docker push
Каждая следующая сборка должна тегировать образ новым тегом (с помощью переменной $GITHUB_RUN_ID).
Создаем новый 'docker-compose-ci.yaml', в котором будет задана конфигурация для разворачивания на сервере:
Заменяем секции build на секции Image с такими же версиями, как при сборке приложения.
Заводим все необходимые секреты в GitHub:
логин и пароль для подключения по SSH (пользователь deploy, созданный на шаге 3);
логин, пароль, название БД (будет использоваться в файле 'docker-compose-ci.yaml' и в конфигурации вашего приложения);
любые другие чувствительные данные.
Добавляем джобу по рендеру 'docker-compose-ci.yaml' и файл конфигурации c помощью envsubst.
Добавляем джобу по копированию двух предыдущих файлов на сервер через SCP.
Добавляем джобу по запуску docker-compose up на самом сервере через SSH.

Шаг 5.
Установили DRF и добавили его в зависимости (requirements.txt) с указанием версии. Добавили 'rest_framework' в settings.
В приложении Core добавили urls.py и в файле todolist/urls.py включили urls из приложения Core.
Добавили файл serializers.py в приложение Core. Описать ModelSerializer
 для регистрации. Необходимо учесть следующие пункты:
нужно проверять надежность пароля с помощью встроенной проверки в Django;
принимать password и password_repeat и проверять, совпадают ли они;
не хранить пароль в исходном виде, а сохранить hash от него;
не создавать двух пользователей с одинаковыми username (допускаются пользователи с одинаковыми email).
Добавили функцию authenticate и функцию login.
Реализовали получение/обновление текущего пользователя и logout.
Реализовать смену пароля. Для реализации этого метода использовали UpdateAPIView.
Добавили библиотеку python social auth в проект и необходимые параметры в конфиг.
Добавили urls в todolist/urls.py:
path("oauth/", include("social_django.urls", namespace="social"))

Шаг 6.
Создали приложение goals и подключили в INSTALLED_APPS.
Создаем в файле models.py модель для категории и делаем миграции.
Добавляем serializer и вьюхи для категории.
Добавляем админку.
Аналогично создали serializer и вьюхи для целей и каментов.

Шаг 7.
Создали модели для досок Board, BoardParticipant, обновили GoalCategory.
Создали новые сущности для каждого пользователя.
Создали миграции и применили их.
Добавляем методы для работы с досками:
- Метод создания доски;
- Методы просмотра/обновления/редактирования доски;
- Метод получения списка досок.
Создаем сериалайзеры и вьюшки.

Шаг 8.
Создали приложение bot и подключили в INSTALLED_APPS.
Сделали модель TgUser, которая описывает состояние пользователя в боте.
Создаем python package (папка "tg" с __init__.py) внутри приложения bot. Внутри tg создаем файл dc: bot/tg/dc.py, 
внутри с помощью dataclass ответы Telegram API.
Внутри tg создаем класс для обращения в Telegram API — bot/tg/client.py. Для запросов используем библиотеку requests.
Написали manage.py команду runbot для получения уведомлений от бота и отправки в ответ пользователю текста, который 
был в уведомлении — то есть написали своего первого echo-бота.
Подтверждение пользователя: для этого реализуем механизм связки пользователя приложения и пользователя Telegram.
Реализовали HTTP-метод PATCH /bot/verify для подтверждения связки с пользователем. При некорректном вводе
verification_code метод вернет ошибку. При корректном - метод вернет HTTP-статус 200 и пришлет сообщение в Telegram об 
успешной связке.
Реализовали команду /goals, которая пришлет все открытые цели пользователя списком. Если бот не нашел совпадение с 
командами, то он ответит отбивкой «неизвестная команда».
Добавлена секция bot в docker-compose.yaml файл. При запуске docker-compose up -d запускается контейнер с ботом.
При написании сообщения в telegram бот отвечает пользователю.
Реализовали команду для создания цели: Бот должен предложить выбрать категорию, затем запросить заголовок цели, после 
этого должен создать цель с введенными значениями и параметрами по умолчанию.
С помощью команды /create можно создать цель. Созданную цель можно найти в списке в приложении.
